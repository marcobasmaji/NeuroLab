#include <iostream>
#include <vector>

#include <fstream>
#include <iostream>
#include <sstream> //std::stringstream
#include <string.h>
#include <time.h>

#include "CL/cl.h"

#include "OpenCLEnvironmentCreator.hpp"
#include "OpenCLEnvironment.hpp"
#include "HardwareType.hpp"
#include "OpenCLLayerCreator.hpp"
#include "OpenCLLayer.hpp"

using namespace std;

float* trainingData;
float* testingData;

int* trainingLabels;
int* testingLabels;

int calculateArrayID(int batch, int map, int y, int x, int maps, int height, int width) {
    return (((batch)*maps + map) * height + y) * width + x;
}

int calculateWeightID(int inputMaps, int height, int width, int outputMap, int inputMap, int y, int x) {
    return (((outputMap)*inputMaps + inputMap) * height + y) * width + x;
}

string loadFile(const char *path) {
	ifstream in(path);
	string contents((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());

	return contents;
}


void loadDataset() {
    int loadImages = 50000;

    trainingData = (float*)malloc(sizeof(float)*loadImages*784);
    trainingLabels = (int*)malloc(sizeof(int) * loadImages);

    ifstream source;                    // build a read-Stream
    source.open("C:/Users/User/Desktop/Kuenstliche Intelligenz/Datasets/MNIST/mnist.txt", ios_base::in);

    string line;
    getline(source, line); 
    getline(source, line); 
    getline(source, line);
    getline(source, line);
    getline(source, line);
    getline(source, line);

    for (int i = 0; i < loadImages; i++) {
        getline(source, line);
        istringstream in(line);

        string character;
        in >> character;
        
        int label = stof(character);
        trainingLabels[i] = label;

        for (int y = 0; y < 28; y++) {
            for (int x = 0; x < 28; x++) {
                in >> character;
                float value = stof(character);
                int id = calculateArrayID(i, 0, y, x, 1, 28, 28);
                trainingData[id] = value;
            }
        }

        if (i % 100 == 0)    cout << i << endl;
    }

    source.close();
}

float* getOutputErrors(int label, float*outputs) {
    float* errors = (float*)malloc(10*sizeof(float));

    float expectedValue = 0;

    for (int i = 0; i < 10; i++) {
        errors[i] = outputs[i]-expectedValue;
    }
    expectedValue = 1;

    errors[label] = outputs[label] - expectedValue;

    return errors;
}

float getError(float*errors) {
    float error = 0;

    for (int i = 0; i < 10; i++) {
        error += errors[i];
    }

    return error;
}

float getRandomValue() {
    return static_cast <float> (rand()) / static_cast <float> (RAND_MAX);
}

float* getWeights(int length) {
    srand(time(NULL));

    float* weights= (float*)malloc(sizeof(float)*length);

    for (int i = 0; i < length; i++) {
        weights[i] = getRandomValue()/length*20;
    }

    return weights;
}

float* getBiases(int length) {
    srand(time(NULL));

    float* weights = (float*)malloc(sizeof(float) * length);

    for (int i = 0; i < length; i++) {
        weights[i] = getRandomValue();
    }

    return weights;
}

int getLabel(int n, int*data) {
    return data[n];
}
float* getData(int n, float* data) {
    float* d = (float*)malloc(sizeof(float)*784);

    for (int i = 0; i < 784; i++){
        d[i] = data[n * 784 + i];
    }

    return d;
}

int getHighestValue(float* values, int length) {
    float value = values[0];
    int index = 0;

    for (int i = 1; i < length; i++) {
        if (value < values[i]) {
            value = values[i];
            index = i;
        }
    }

    return index;
}

void testWithMnist() {
    loadDataset();

    
    OpenCLEnvironmentCreator* openCLEnvironmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = openCLEnvironmentCreator->createOpenCLEnvironment(hardwareType);
    OpenCLLayerCreator* openCLLayerCreator = new OpenCLLayerCreator();

    OpenCLLayer* denseLayer1 = openCLLayerCreator->createDenseLayer(openCLEnvironment, 1, 1, 28, 28, 30);
    {
        float* weights1 = getWeights(30 * 28 * 28);
        float* biases1 = getBiases(30);
        denseLayer1->setWeights(openCLEnvironment, weights1, 30 * 28 * 28);
        denseLayer1->setBiases(openCLEnvironment, biases1, 30);
        denseLayer1->setLearningRate(0.0075);
        free(weights1);
        free(biases1);
    }
    OpenCLLayer* reluLayer1 = openCLLayerCreator->createReluLayer(openCLEnvironment, 1, 30, 1, 1);
    OpenCLLayer* denseLayer2 = openCLLayerCreator->createDenseLayer(openCLEnvironment, 1, 30, 1, 1, 10);
    {
        float* weights2 = getWeights(10*30);
        float* biases2 = getBiases(10);
        denseLayer2->setWeights(openCLEnvironment, weights2, 10 * 30);
        denseLayer2->setBiases(openCLEnvironment, biases2, 10);
        denseLayer2->setLearningRate(0.0075);
        free(weights2);
        free(biases2);
    }

    OpenCLLayer* reluLayer2 = openCLLayerCreator->createReluLayer(openCLEnvironment, 1, 10, 1, 1);
    
    reluLayer1->setPreviousOpenCLLayer(denseLayer1);
    denseLayer2->setPreviousOpenCLLayer(reluLayer1);
    reluLayer2->setPreviousOpenCLLayer(denseLayer2);
    
    int correct = 0;

    for (int epoch = 0; epoch < 30;epoch++) {
        for (int itt = 0; itt < 50000; itt++) {
            int label = getLabel(itt, trainingLabels);
            float* data = getData(itt, trainingData);

            denseLayer1->setInputs(openCLEnvironment, data, 784);

            denseLayer1->computeForward(openCLEnvironment, 1, 30);
            reluLayer1->computeForward(openCLEnvironment, 1, 30);
            denseLayer2->computeForward(openCLEnvironment, 1, 10);
            reluLayer2->computeForward(openCLEnvironment, 1, 10);

            int length;
            float* output = reluLayer2->getOutputs(openCLEnvironment, 1, 10, 1, 1, &length);
            float* error = getOutputErrors(label, output);
            reluLayer2->setOutputErrors(openCLEnvironment, error, 10);

            reluLayer2->computeErrorComp(openCLEnvironment, 1);
            denseLayer2->computeErrorComp(openCLEnvironment, 1);
            reluLayer1->computeErrorComp(openCLEnvironment, 1);
            denseLayer1->computeErrorComp(openCLEnvironment, 1);

            denseLayer1->computeWeightsUpdate(openCLEnvironment, 10);
            denseLayer2->computeWeightsUpdate(openCLEnvironment, 30);

            if (epoch == 29) {
                if (label == getHighestValue(output, 10)) correct++;

                if (itt % 100 == 0) {
                    cout << label << "  " << correct << "  ";
                    for (int i = 0; i < 10; i++) {
                        cout << output[i] << "  ";
                    }cout << endl;
                }
            }

            
            free(output);
            free(error);
            free(data);
        }

        cout << epoch << endl;
    }
    

    /*
    denseLayer1->setLearningRate(0.1);
    int length1 = 28 * 28 * 30;
    denseLayer1->setWeights(openCLEnvironment, getWeights(denseLayer1, length1), length1);
    OpenCLLayer* denseLayer2 = openCLLayerCreator->createDenseLayer(openCLEnvironment, 1, 30, 1, 1, 10);
    denseLayer2->setLearningRate(0.1);
    int length2 = 30 * 10;
    denseLayer2->setWeights(openCLEnvironment, getWeights(denseLayer2, length2), length2);

    denseLayer2->setPreviousOpenCLLayer(denseLayer1);

    for (int epoch = 0; epoch < 1; epoch++) {
        for (int itt = 0; itt < 1; itt++) {
            float* data = trainingData.at(itt);
            int label = trainingLabels.at(itt);

            denseLayer1->setInputs(openCLEnvironment, data, 784);

            denseLayer1->computeForward(openCLEnvironment, 1, 30);
            denseLayer2->computeForward(openCLEnvironment, 1, 10);

            int* arrayLength = (int*)malloc(sizeof(int));
            float* outputs = denseLayer1->getOutputs(openCLEnvironment, 1, 10, 1, 1, arrayLength);



            float* outputErrors = getOutputErrors(label, outputs);
            cout << outputs[0] << endl;

            free(arrayLength);
        }
    }

    free(denseLayer1);
    free(denseLayer2);
    
    delete openCLEnvironmentCreator;
    delete openCLEnvironment;
    */
    free(trainingData);
    free(testingData);

    free(trainingLabels);
    free(testingLabels);
}

float* createInputs(int batchSize, int inputMaps, int inputHeight, int inputWidth) {
    float* inputs = (float*)malloc(sizeof(float)*batchSize*inputMaps*inputHeight*inputWidth);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < inputMaps; map++) {
            for (int y = 0; y < inputHeight; y++) {
                for (int x = 0; x < inputWidth; x++) {
                    int id = calculateArrayID(batch, map, y, x, inputMaps, inputHeight, inputWidth);
                    inputs[id]=id-20;
                    id++;
                }
            }
        }
    }

    return inputs;
}

//checked
void testDenseLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 1;
    int inputMaps = 1;
    int inputHeight = 6;
    int inputWidth = 6;
    int outputNeurons = 3;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* convLayer = layerCreator->createDenseLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, outputNeurons);

    float* inputs = (float*)malloc(sizeof(float) * inputMaps * inputHeight * inputWidth);
    {
        int y, x;
        y = 0;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 8;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 4;

        y = 1;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 0;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 7;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;

        y = 2;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;

        y = 3;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 4;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;

        y = 4;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 7;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;

        y = 5;
        x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 9;
        x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;
        x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
        x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;
        x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    }
    convLayer->setInputs(openCLEnvironment, inputs, batchSize * inputMaps * inputHeight * inputWidth);

    float* weights = (float*)malloc(sizeof(float) * inputMaps* inputHeight* inputWidth* outputNeurons);

    {
        int i = 0;
        for (int outputNeuron = 0; outputNeuron < outputNeurons; outputNeuron++) {
            for (int inputMap = 0; inputMap < inputMaps; inputMap++) {
                for (int y = 0; y < inputHeight; y++) {
                    for (int x = 0; x < inputWidth; x++) {
                        weights[calculateWeightID(inputMaps, inputHeight, inputWidth, outputNeuron, 0, y, x)] = i;
                        i++;
                    }
                }
            }
        }
    }
    convLayer->setWeights(openCLEnvironment, weights, inputMaps * inputHeight * inputWidth * outputNeurons);

    float* biases = (float*)malloc(sizeof(float) * 3);
    biases[0] = 7;
    biases[1] = 6;
    biases[2] = 5;
    convLayer->setBiases(openCLEnvironment, biases, outputNeurons);

    convLayer->computeForward(openCLEnvironment, batchSize, outputNeurons);

    int length;
    float* outputs = convLayer->getOutputs(openCLEnvironment, batchSize, outputNeurons, 1, 1, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < outputNeurons; map++) {
            for (int y = 0; y < 1; y++) {
                for (int x = 0; x < 1; x++) {
                    int id = calculateArrayID(batch, map, y, x, outputNeurons, 1, 1);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout << endl;
            }cout << endl;
        }cout << endl;
    }
}
//checked
void testConvLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 1;
    int inputMaps = 1;
    int inputHeight = 6;
    int inputWidth = 6;
    int outputMaps = 1;
    int outputHeight = 4;
    int outputWidth = 4;
    int strideHeight = 1;
    int strideWidth = 1;
    int kernelHeight = 3;
    int kernelWidth = 3;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* convLayer = layerCreator->createConvLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, outputMaps, outputHeight, outputWidth, kernelHeight, kernelWidth, strideHeight, strideWidth);

    float* inputs = (float*)malloc(sizeof(float)*inputMaps*inputHeight*inputWidth);

    {int y, x;
    y = 0;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 8;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 4;

    y = 1;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 0;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 7;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;

    y = 2;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;

    y = 3;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 4;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;

    y = 4;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 3;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 7;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;

    y = 5;
    x = 0; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 9;
    x = 1; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 2; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 6;
    x = 3; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 2;
    x = 4; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 5;
    x = 5; inputs[calculateArrayID(0, 0, y, x, 1, 6, 6)] = 1;
    }

    convLayer->setInputs(openCLEnvironment, inputs, batchSize * inputMaps * inputHeight * inputWidth);

    float* weights = (float*)malloc(sizeof(float)*outputMaps*inputMaps*kernelHeight*kernelWidth);

    {int y = 0, x;
    x = 0; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 1;
    x = 1; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 0;
    x = 2; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = -1;

    y = 1;
    x = 0; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 1;
    x = 1; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 0;
    x = 2; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = -1;

    y = 2;
    x = 0; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 1;
    x = 1; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = 0;
    x = 2; weights[calculateWeightID(1, 3, 3, 0, 0, y, x)] = -1;
    }

    convLayer->setWeights(openCLEnvironment, weights, outputMaps * inputMaps * kernelHeight * kernelWidth);

    float* biases = (float*)malloc(sizeof(float)*1);
    biases[0] = 7;
    convLayer->setBiases(openCLEnvironment, biases, outputMaps);

    convLayer->computeForward(openCLEnvironment, batchSize, outputMaps);

    int length;
    float* outputs = convLayer->getOutputs(openCLEnvironment, batchSize, outputMaps, outputHeight, outputWidth, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < outputMaps; map++) {
            for (int y = 0; y < outputHeight; y++) {
                for (int x = 0; x < outputWidth; x++) {
                    int id = calculateArrayID(batch, map, y, x, outputMaps, outputHeight, outputWidth);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout << endl;
            }cout << endl;
        }cout << endl;
    }
}
//checked
void testMaxPoolLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 2;
    int inputMaps = 3;
    int inputHeight = 4;
    int inputWidth = 4;
    int outputHeight = 2;
    int outputWidth = 2;
    int strideHeight = 1;
    int strideWidth = 1;
    int poolHeight = 3;
    int poolWidth = 3;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* maxPoolLayer = layerCreator->createMaxPoolLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, outputHeight, outputWidth, poolHeight, poolWidth, strideHeight, strideWidth);

    float* inputs = createInputs(batchSize, inputMaps, inputHeight, inputWidth);

    maxPoolLayer->setInputs(openCLEnvironment, inputs, batchSize * inputMaps * inputHeight * inputWidth);

    maxPoolLayer->computeForward(openCLEnvironment, batchSize, inputMaps);
    
    int length;
    float* outputs = maxPoolLayer->getOutputs(openCLEnvironment, batchSize, inputMaps, outputHeight, outputWidth, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < inputMaps; map++) {
            for (int y = 0; y < outputHeight; y++) {
                for (int x = 0; x < outputWidth; x++) {
                    int id = calculateArrayID(batch, map, y, x, inputMaps, outputHeight, outputWidth);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout << endl;
            }cout << endl;
        }cout << endl;
    }
}
//checked
void testSoftmaxLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 2;
    int inputMaps = 3;
    int inputHeight = 4;
    int inputWidth = 4;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* softmaxLayer = layerCreator->createSoftmaxLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth);
    
    float* inputs = createInputs(batchSize, inputMaps, inputHeight, inputWidth);

    softmaxLayer->setInputs(openCLEnvironment, inputs, batchSize * inputMaps * inputHeight * inputWidth);

    softmaxLayer->computeForward(openCLEnvironment, batchSize, inputMaps);

    int length;
    float* outputs = softmaxLayer->getOutputs(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < inputMaps; map++) {
            for (int y = 0; y < inputHeight; y++) {
                for (int x = 0; x < inputWidth; x++) {
                    int id = calculateArrayID(batch, map, y, x, inputMaps, inputHeight, inputWidth);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout << endl;
            }cout << endl;
        }cout << endl;
    }
}
//checked
void testReluLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 2;
    int inputMaps = 3;
    int inputHeight = 4;
    int inputWidth = 4;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* reluLayer = layerCreator->createReluLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth);

    float* inputs = createInputs(batchSize, inputMaps, inputHeight, inputWidth);

    reluLayer->setInputs(openCLEnvironment, inputs, batchSize * inputMaps * inputHeight * inputWidth);

    reluLayer->computeForward(openCLEnvironment, batchSize, inputMaps);

    int length;
    float* outputs = reluLayer->getOutputs(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < inputMaps; map++) {
            for (int y = 0; y < inputHeight; y++) {
                for (int x = 0; x < inputWidth; x++) {
                    int id = calculateArrayID(batch, map, y, x, inputMaps, inputHeight, inputWidth);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout << endl;
            }cout << endl;
        }cout << endl;
    }
}
//checked
void testPadLayer() {
    OpenCLEnvironmentCreator* environmentCreator = new OpenCLEnvironmentCreator();
    HardwareType hardwareType = HardwareType::CPU;
    OpenCLEnvironment* openCLEnvironment = environmentCreator->createOpenCLEnvironment(hardwareType);

    int batchSize = 2;
    int inputMaps = 3;
    int inputHeight = 4;
    int inputWidth = 4;
    int padHeight = 2;
    int padWidth = 2;

    OpenCLLayerCreator* layerCreator = new OpenCLLayerCreator();
    OpenCLLayer* padLayer = layerCreator->createPadLayer(openCLEnvironment, batchSize, inputMaps, inputHeight, inputWidth, padHeight, padWidth);

    float* inputs = createInputs(batchSize, inputMaps, inputHeight, inputWidth);

    padLayer->setInputs(openCLEnvironment, inputs, batchSize*inputMaps*inputHeight*inputWidth);

    padLayer->computeForward(openCLEnvironment, batchSize, inputMaps);

    int length;
    float* outputs = padLayer->getOutputs(openCLEnvironment, batchSize, inputMaps, inputHeight+2*padHeight, inputWidth+2*padWidth, &length);

    for (int batch = 0; batch < batchSize; batch++) {
        for (int map = 0; map < inputMaps; map++) {
            for (int y = 0; y < inputHeight+2*padHeight; y++) {
                for (int x = 0; x < inputWidth + 2 * padWidth; x++) {
                    int id = calculateArrayID(batch, map, y,x, inputMaps, inputHeight + 2 * padHeight, inputWidth + 2 * padWidth);
                    float value = outputs[id];
                    cout << value << "\t";
                }cout<<endl;
            }cout << endl;
        }cout << endl;
    }
}

void printOpenCLPlatformsAndDevices(){
    int i, j;
    char* value;
    size_t valueSize;
    cl_uint platformCount;
    cl_platform_id* platforms;
    cl_uint deviceCount;
    cl_device_id* devices;
    cl_uint maxComputeUnits;

    // get all platforms
    clGetPlatformIDs(0, NULL, &platformCount);
    platforms = (cl_platform_id*) malloc(sizeof(cl_platform_id) * platformCount);
    clGetPlatformIDs(platformCount, platforms, NULL);

    for (i = 0; i < platformCount; i++) {

        // get all devices
        clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
        devices = (cl_device_id*) malloc(sizeof(cl_device_id) * deviceCount);
        clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, deviceCount, devices, NULL);

        // for each device print critical attributes
        for (j = 0; j < deviceCount; j++) {

            // print device name
            clGetDeviceInfo(devices[j], CL_DEVICE_NAME, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_NAME, valueSize, value, NULL);
            printf("%d. Device: %s\n", j+1, value);
            free(value);

            // print hardware device version
            clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, valueSize, value, NULL);
            printf(" %d.%d Hardware version: %s\n", j+1, 1, value);
            free(value);

            // print software driver version
            clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, valueSize, value, NULL);
            printf(" %d.%d Software version: %s\n", j+1, 2, value);
            free(value);

            // print c version supported by compiler for device
            clGetDeviceInfo(devices[j], CL_DEVICE_OPENCL_C_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_OPENCL_C_VERSION, valueSize, value, NULL);
            printf(" %d.%d OpenCL C version: %s\n", j+1, 3, value);
            free(value);

            // print parallel compute units
            clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS,
                    sizeof(maxComputeUnits), &maxComputeUnits, NULL);
            printf(" %d.%d Parallel compute units: %d\n", j+1, 4, maxComputeUnits);

        }

        free(devices);

    }

    free(platforms);
}

int main() {
	printOpenCLPlatformsAndDevices();

   /* testPadLayer();
    testReluLayer();
    testSoftmaxLayer();
    testMaxPoolLayer();
    testConvLayer();
    testDenseLayer();*/

    //testWithMnist();

    return 0;
}
